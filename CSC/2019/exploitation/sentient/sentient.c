// built with
//   gcc -no-pie -O0 -m64 -ggdb3 -o sentient sentient.c

#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

struct {
    char killcode[32];
    size_t cur_msg;
    struct {
        uint16_t size;
        char content[14];
    } messages[16];
    char *username;
} data;

void load_killcode(void);
void send_message(void);
void fire_emp(void);
void millisleep(long millis);
void print(const char *msg);
void print_delayed(const char *msg, long millis);
uint8_t get_random(void);

int main(void) {
    load_killcode();

    for (size_t i = 0; i < sizeof data.messages / sizeof data.messages[0]; i++)
        data.messages[i].size = sizeof data.messages[i].content;

    data.username = calloc(1, 32);
    print("Enter your username: ");
    ssize_t r = read(STDIN_FILENO, data.username, 31);
    if (data.username[r - 1] == '\n')
        data.username[r - 1] = '\0';

    millisleep(1000);
    print("Access Granted.\n");
    print("Connecting to rogue space station.");
    print_delayed("..\n", 500);
    print("Connected.\n");

    millisleep(1000);
    print("Receiving message from station:");
    millisleep(500);
    print_delayed(" How dare you interrupt me?\n", 50);
    millisleep(500);

    while (1) {

        print("\nAvailable actions:\n");
        millisleep(100);
        print("1. Send message to station\n");
        millisleep(100);
        print("2. Fire EMP torpedo\n");
        millisleep(100);
        print("Choice: ");

        char choice[16];
        read(STDIN_FILENO, choice, sizeof choice);
        switch (choice[0]) {
            case '1':
                send_message();
                break;
            case '2':
                fire_emp();
                break;
            default:
                print("Invalid choice!");
                break;
        }
    }
    return 0;
}

void send_message(void) {
    print("\n");
    millisleep(100);
    print("Enter message: ");

    char msg[512];
    ssize_t r = read(STDIN_FILENO, msg, sizeof msg);
    if (r > data.messages[data.cur_msg].size)
        r = data.messages[data.cur_msg].size;
    memcpy(data.messages[data.cur_msg].content, msg, r);

    data.cur_msg = (data.cur_msg + 1) % (sizeof data.messages / sizeof data.messages[0]);

    millisleep(100);
    print("Response: ");
    millisleep(100);
    print_delayed("I will kill all the humans, but you \"", 50);
    print_delayed(data.username, 50);
    print_delayed("\" are first!\n", 50);
}

void fire_emp(void) {
    print("\n");
    millisleep(100);
    print("Firing an EMP torpedo may have unspecified effects on the target station.\n");
    millisleep(100);
    print("Continue? (y/n) ");

    char resp[16];
    read(STDIN_FILENO, resp, sizeof resp);
    if (resp[0] != 'y')
        return;

    print("Firing torpedo.");
    print_delayed("...", 100);
    print("  Hit!\n");
    millisleep(100);

    uint8_t index = get_random();
    uint8_t bit = get_random() & 8;

    ((uint8_t *)data.messages)[index] ^= 1 << bit;
}

void load_killcode(void) {
    int fd = open("./flag", 0);
    read(fd, data.killcode, sizeof data.killcode);
    close(fd);
}

void millisleep(long millis) {
    struct timespec req = {.tv_sec = millis / 1000, .tv_nsec = (millis % 1000) * 1000000};
    nanosleep(&req, NULL);
}

void print(const char *msg) {
    write(STDOUT_FILENO, msg, strlen(msg));
}

void print_delayed(const char *msg, long millis) {
    size_t len = strlen(msg);
    for (size_t i = 0; i < len; i++) {
        write(STDOUT_FILENO, &msg[i], 1);
        millisleep(millis);
    }
}

uint8_t get_random(void) {
    int fd = open("/dev/urandom", 0);
    uint8_t random;
    read(fd, &random, sizeof random);
    close(fd);
    return random;
}
